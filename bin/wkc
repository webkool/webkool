#! /usr/bin/env node
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
function printTabs(nbr) {
    var str = '';
    for (var i = 0; i < nbr; i++)
        str += '\t';
    return (str);
}

function epurString(str) {
    return str.replace(/^\s*$/, '');
}

function sanitize(str) {
    var res = '';

    str.split('\n').forEach(function (itm, idx, col) {
        if (!((idx == 0 || idx == col.length - 1) && epurString(itm) == ''))
            res += itm + '\n';
    });
    return (res);
}

var Webkool;
(function (Webkool) {
    'use strict';

    /*
    ** Template and Css Engine
    */
    var version = '0.3.0';

    var templateEngine = {
        'square': require('../lib/square'),
        'mustache': require('../lib/mustache')
    };

    var styleSheetEngine = {
        'css': '',
        'less': require('../lib/less'),
        'sass': require('../lib/sass')
    };

    /*
    **	require
    */
    var expat = require('node-expat');
    var sm = require('source-map');
    var sbuff = require('stream-buffers');
    var jshint = require('jshint').JSHINT;
    var fs = require('fs');
    var pathm = require('path');
    var async = require('async');

    var outputJS, outputCSS, pr, options = {
        client: false,
        server: false,
        target: {},
        includes: [__dirname + '/../lib/client/', ''],
        inputs: [],
        output: '',
        jshint: ''
    };

    var SideType;
    (function (SideType) {
        SideType[SideType["BOTH"] = 0] = "BOTH";
        SideType[SideType["SERVER"] = 1] = "SERVER";
        SideType[SideType["CLIENT"] = 2] = "CLIENT";
    })(SideType || (SideType = {}));
    ;

    function printHintErrors(errors, sourceMap, output) {
        var smc = new sm.SourceMapConsumer(sourceMap);

        errors.forEach(function (itm) {
            if (itm == null)
                console.log('to many Errors, please fix your code');
else {
                var location = smc.originalPositionFor({
                    line: itm.line,
                    column: itm.character
                });
                var dirname = pathm.dirname(output);
                var fullPath = pathm.resolve(pathm.dirname(output));

                if (location.line != null) {
                    var path = pathm.resolve(fullPath, pathm.relative(fullPath, location.source));
                    console.log(itm.id, itm.code, itm.reason, 'in file', path + ':' + location.line + ':' + location.column);
                } else {
                    var path = pathm.resolve(fullPath, pathm.relative(fullPath, sourceMap.file));
                    console.log(itm.id, itm.code, itm.reason, 'in file', path + ':' + itm.line + ':' + itm.character);
                }
            }
        });
    }

    /*
    **	BufferManager
    */
    var PathRes = (function () {
        function PathRes(output) {
            this.output = output;
            this.root = this.getDirFromPath(output);
            this.file = this.getFileFromPath(output);
            this.sm = this.root + 'source-map/';
            this.currentFolder = pathm.resolve() + '/';
        }
        PathRes.prototype.getRoot = function () {
            return (this.root);
        };

        PathRes.prototype.getSide = function (client, server) {
            return ((client && server) || (!client && !server)) ? (SideType.BOTH) : ((client) ? (SideType.CLIENT) : (SideType.SERVER));
        };

        PathRes.prototype.getFile = function () {
            return (this.file);
        };

        PathRes.prototype.getOutputFile = function (side) {
            var filename = this.file;
            var client = null;
            var server = null;

            if (side == SideType.CLIENT)
                client = filename + ((filename[filename.length - 1] == '/') ? ('client') : (''));
            if (side == SideType.SERVER)
                server = filename + ((filename[filename.length - 1] == '/') ? ('server') : (''));
            if (side == SideType.BOTH) {
                client = filename + ((filename[filename.length - 1] == '/') ? ('') : ('.')) + 'client';
                server = filename + ((filename[filename.length - 1] == '/') ? ('') : ('.')) + 'server';
            }
            return ([client, server]);
        };

        PathRes.prototype.getSourceMap = function () {
            return (this.sm);
        };
        PathRes.prototype.getCurrentFolder = function () {
            return (this.currentFolder);
        };

        PathRes.prototype.getSourceMapName = function (side) {
            var filename = this.sm + this.file;
            var client = null;
            var server = null;

            if (side == SideType.CLIENT)
                client = filename + ((filename[filename.length - 1] == '/') ? ('client') : (''));
            if (side == SideType.SERVER)
                server = filename + ((filename[filename.length - 1] == '/') ? ('server') : (''));
            if (side == SideType.BOTH) {
                client = filename + ((filename[filename.length - 1] == '/') ? ('') : ('.')) + 'client';
                server = filename + ((filename[filename.length - 1] == '/') ? ('') : ('.')) + 'server';
            }
            return ([client, server]);
        };

        PathRes.prototype.getOutputName = function (side) {
            var filename = this.root + this.file;
            var client = null;
            var server = null;

            if (side == SideType.CLIENT)
                client = filename + ((filename[filename.length - 1] == '/') ? ('client') : (''));
            if (side == SideType.SERVER)
                server = filename + ((filename[filename.length - 1] == '/') ? ('server') : (''));
            if (side == SideType.BOTH) {
                client = filename + ((filename[filename.length - 1] == '/') ? ('') : ('.')) + 'client';
                server = filename + ((filename[filename.length - 1] == '/') ? ('') : ('.')) + 'server';
            }
            return ([client, server]);
        };

        PathRes.prototype.resolve = function (that, path) {
            var res = pathm.resolve(that + path);
            if (path.length === 0)
                return (this.root);
else if (path[path.length - 1] == '/')
                return (res + '/');
            return (res);
        };

        PathRes.prototype.resolveCheck = function (file, inc) {
            var np = '';
            for (var i = 0; i < inc.length; i++) {
                np = pathm.resolve(inc[i] + file);
                if (fs.existsSync(np))
                    return (np);
            }
            return (null);
        };

        PathRes.prototype.getRelative = function (p1, p2) {
            return (pathm.relative(p1, p2));
        };

        PathRes.prototype.getDirFromPath = function (path) {
            var res = pathm.resolve(path) + (path == '' ? '/' : '');
            if (path.length > 0 && res[res.length - 1] != '/' && path[path.length - 1] == '/')
                res += '/';
            if (path.length > 0 && path[path.length - 1] != '/')
                res = res.substr(0, res.lastIndexOf('/')) + '/';
            return (res);
        };

        PathRes.prototype.getFileFromPath = function (path) {
            var file = '';
            var res = pathm.resolve(path) + (path == '' ? '/' : '');
            if (path.length > 0 && path[path.length - 1] != '/')
                file = res.substr(res.lastIndexOf('/') + 1);
            return (file);
        };
        return PathRes;
    })();

    var BufferManager = (function () {
        function BufferManager() {
            this.buffers = [];
        }
        BufferManager.prototype.newBuffer = function (neededSide, name) {
            this.buffers.push({
                'name': name,
                'side': neededSide,
                'data': []
            });
        };

        BufferManager.prototype.get = function (side, name, create) {
            for (var i = 0; i < this.buffers.length; i++) {
                if (this.buffers[i].name == name && this.buffers[i].side == side)
                    return (this.buffers[i]);
            }
            if (create) {
                this.newBuffer(side, name);
                return (this.get(side, name, false));
            }
            return (undefined);
        };

        BufferManager.prototype.write = function (side, name, data, info, split) {
            if (side == SideType.BOTH) {
                this.write(SideType.SERVER, name, data, info, split);
                this.write(SideType.CLIENT, name, data, info, split);
            } else {
                // if info == null, the chunk will be not add to the source map
                var buff = this.get(side, name, true);

                if (split == true) {
                    data.split('\n').forEach(function (itm, idx, col) {
                        var infoTmp = {
                            line: info.line + idx,
                            col: info.col,
                            file: info.file
                        };

                        if ((idx == 0 || idx == col.length - 1) && epurString(itm) == '')
                            infoTmp = null;

                        buff.data.push({
                            data: itm + '\n',
                            info: infoTmp
                        });
                    });
                } else {
                    buff.data.push({
                        data: data,
                        info: info
                    });
                }
            }
        };

        BufferManager.prototype.getBuffers = function () {
            return (this.buffers);
        };

        BufferManager.prototype.exec = function (side, name, callback) {
            callback(this.get(side, name, false));
        };

        BufferManager.prototype.copy = function (other) {
            this.buffers = other.getBuffers();
        };

        BufferManager.prototype.insert = function (side, name, elm, info) {
            var buff = this.get(side, name, true);
            buff.data.push({
                data: elm,
                info: info
            });
        };

        BufferManager.prototype.merge = function (side, other, info) {
            if (side == SideType.BOTH) {
                this.merge(SideType.SERVER, other, info.line);
                this.merge(SideType.CLIENT, other, info.line);
            } else {
                var buff = other.getBuffers();

                for (var i = 0; i < buff.length; i++) {
                    if (buff[i].side == side || buff[i].side == SideType.BOTH) {
                        this.insert(side, buff[i].name, buff[i].data, info);
                    }
                }
            }
        };

        BufferManager.prototype.profoundToSourceMap = function (map, line, elm) {
            for (var i = 0; i < elm.length; i++) {
                var itm = elm[i];
                if (itm.data instanceof Array)
                    line = this.profoundToSourceMap(map, line, itm.data);
else {
                    if (itm.info != null) {
                        map.addMapping({
                            'generated': {
                                'line': line,
                                'column': 0
                            },
                            'source': itm.info.file,
                            'original': {
                                'line': itm.info.line,
                                'column': itm.info.col
                            }
                        });
                    } else {
                        map.addMapping({
                            generated: {
                                line: line,
                                column: 0
                            }
                        });
                    }
                    line += itm.data.split('\n').length - 1;
                }
            }
            return (line);
        };

        BufferManager.prototype.toSourceMap = function (side, name, filename) {
            var map = new sm.SourceMapGenerator({ file: filename });
            var generatedLine = 1;
            var buff = this.get(side, name, false);

            if (typeof buff !== 'undefined') {
                for (var i = 0; i < buff.data.length; i++) {
                    var elm = buff.data[i];
                    if (elm.data instanceof Array) {
                        generatedLine = this.profoundToSourceMap(map, generatedLine, elm.data);
                    } else {
                        if (elm.info != null) {
                            map.addMapping({
                                generated: {
                                    line: generatedLine,
                                    column: 0
                                },
                                source: elm.info.file,
                                original: {
                                    line: elm.info.line,
                                    column: elm.info.col
                                }
                            });
                        } else {
                            map.addMapping({
                                generated: {
                                    line: generatedLine,
                                    column: 0
                                }
                            });
                        }
                        generatedLine += elm.data.split('\n').length - 1;
                    }
                }
            }
            return (map);
        };

        //output generation
        BufferManager.prototype.profoundToString = function (data) {
            var output = '';

            var _this = this;
            data.forEach(function (elm) {
                if (elm.data instanceof Array)
                    output += _this.profoundToString(elm.data);
else
                    output += elm.data;
            });
            return (output);
        };

        BufferManager.prototype.toString = function (side, name) {
            var output = '';
            var buff = this.get(side, name, false);
            var _this = this;

            if (typeof buff !== 'undefined') {
                buff.data.forEach(function (elm) {
                    if (elm.data instanceof Array)
                        output += _this.profoundToString(elm.data);
else
                        output += elm.data;
                });
            }
            return (output);
        };

        BufferManager.prototype.dump = function () {
            console.log('##################################');
            for (var i = 0; i < this.buffers.length; i++) {
                console.log('[' + this.buffers[i].name + '][' + this.buffers[i].side + '] = ');
                for (var j = 0; j < this.buffers[i].data.length; j++) {
                    console.log('\t\t[' + j + ']', this.buffers[i].data[j]);
                }
                console.log('------------------------------');
            }
            console.log('##################################\n');
        };
        return BufferManager;
    })();

    /*
    **	Nodes
    */
    function loadExternFile(context, parser, filename, putInBuffer) {
        var found = false;
        var element = context;
        var extension = '.' + filename.split('.').pop();
        var content = '';
        var readIncludeFile = function (parser, element, filename, extension) {
            try  {
                var res = '';
                if (putInBuffer == true)
                    res += '/* include ' + filename + ' */\n';
                res += fs.readFileSync(filename, 'utf-8');
                if (putInBuffer == true)
                    element.preparedBuffers.write(SideType.BOTH, extension, res, null, false);
else
                    content = res;
                parser.dequeue(element);
                return (true);
            } catch (e) {
                return (false);
            }
        };

        parser.wait(context);
        context.outputType = extension;

        if (!readIncludeFile(parser, element, filename, extension)) {
            for (var i = 0; i < options.includes.length; i++) {
                var newName = options.includes[i] + context.attrs.href;
                if (readIncludeFile(parser, element, newName, extension)) {
                    found = true;
                    break;
                }
            }
        } else {
            found = true;
        }
        if (found === false) {
            throw Error('file not found <' + context.attrs.href + '>');
        }
        if (putInBuffer == false) {
            return (content);
        }
    }

    var Element = (function () {
        function Element(parser, name, attrs, filename) {
            this.line = parser.getCurrentLineNumber();
            this.location = {
                line: parser.getCurrentLineNumber(),
                col: parser.getCurrentColumnNumber(),
                file: filename
            };
            this.start(parser, name, attrs);
        }
        Element.prototype.start = function (parser, name, attrs) {
            if (parser.currentElement) {
                parser.currentElement.processText(parser);
                parser.currentElement.children.push(this);
            }

            this.parent = parser.currentElement;
            this.children = [];
            this.name = name;
            this.attrs = attrs;
            this.text = '';
            this.outputType = '.js';
            parser.currentElement = this;
        };

        Element.prototype.checkAttrs = function (attrs, location, tagName) {
            for (var name in attrs) {
                if (this.elementAttrs.indexOf(name) == -1) {
                    throw Error('invalid attribute <' + name + '> (' + tagName + ') in file ' + location.file + ' (' + location.line + ':' + location.col + ')');
                }
            }
        };

        Element.prototype.stop = function (parser, name) {
            this.processText(parser);
            parser.currentElement = this.parent;
        };

        Element.prototype.prepare = function (parser) {
            this.checkAttrs(this.attrs, this.location, this.name);
            this.children.forEach(function (item) {
                item.prepare(parser);
            });
        };

        Element.prototype.processElement = function (parser, name, attrs) {
            if (this.elementRules.hasOwnProperty(name)) {
                return new (this.elementRules[name])(parser, name, attrs, this.location.file);
            }
            parser.error('Element not found <' + name + '>');
        };

        Element.prototype.processText = function (parser) {
            this.text += parser.currentText;
            parser.currentText = '';
        };

        Element.prototype.print = function (buffers, side) {
            this.printHeader(buffers, side);
            this.printBody(buffers, side);
            this.printFooter(buffers, side);
        };

        Element.prototype.printHeader = function (buffers, side) {
        };

        Element.prototype.printBody = function (buffers, side) {
            this.children.forEach(function (item) {
                item.print(buffers, side);
            });
        };

        Element.prototype.printFooter = function (buffers, side) {
        };

        Element.prototype.getLocation = function (offsetLine, offsetColumn) {
            var location = this.location;

            location.line += offsetLine;
            location.col += offsetColumn;
            return (location);
        };
        return Element;
    })();

    var Include = (function (_super) {
        __extends(Include, _super);
        function Include(parser, name, attrs, filename) {
            _super.call(this, parser, name, attrs, filename);
            this.elementRules = {};
            this.elementAttrs = ['href'];
            this.name = 'include';
            this.parser = parser;
            this.preparedBuffers = new BufferManager();
        }
        Include.prototype.prepare = function (parser) {
            this.checkAttrs(this.attrs, this.location, this.name);
            var element = this;
            var filename = pr.resolveCheck(this.attrs.href, options.includes);

            var extension = pathm.extname(filename);
            console.log('# including ' + filename);
            parser.wait(this);
            this.outputType = '.wk';
            doParseDocument(filename, function (buffers) {
                element.preparedBuffers = buffers;
                parser.dequeue(element);
            });
        };

        Include.prototype.printBody = function (buffers, side) {
            buffers.merge(side, this.preparedBuffers, this.location.line);
        };
        return Include;
    })(Element);

    var On = (function (_super) {
        __extends(On, _super);
        function On(parser, name, attrs, filename) {
            _super.call(this, parser, name, attrs, filename);
            this.elementRules = {};
            this.elementAttrs = ['id'];
            this.name = 'on';
        }
        On.prototype.printBody = function (buffers, side) {
            var begin = 'on_' + this.attrs.id + ': { value: function(context, model, query, result) {';
            var middle = this.text;
            var end = '}},\n';

            var newLocation = {
                line: this.location.line,
                col: this.location.col,
                file: pr.resolveCheck(this.location.file, options.includes)
            };

            buffers.write(side, this.outputType, begin, null, false);
            buffers.write(side, this.outputType, middle, newLocation, true);
            buffers.write(side, this.outputType, end, null, false);
        };
        return On;
    })(Element);

    var Property = (function (_super) {
        __extends(Property, _super);
        function Property(parser, name, attrs, filename) {
            _super.call(this, parser, name, attrs, filename);
            this.elementRules = {};
            this.elementAttrs = ['id'];
            this.name = 'property';
        }
        Property.prototype.printBody = function (buffers, side) {
            if (!this.attrs.hasOwnProperty('id'))
                throw new Error('properties must have an id!');

            var data = '';

            data += 'application.addProperty(\"';
            data += this.attrs.id;
            data += '\", \"';
            data += this.text;
            data += '\");\n';

            buffers.write(side, this.outputType, data, null, false);
        };
        return Property;
    })(Element);

    var Script = (function (_super) {
        __extends(Script, _super);
        function Script(parser, name, attrs, filename) {
            _super.call(this, parser, name, attrs, filename);
            this.elementRules = {};
            this.elementAttrs = ['href'];
            this.name = 'script';
            this.preparedBuffers = new BufferManager();
        }
        Script.prototype.prepare = function (parser) {
            this.checkAttrs(this.attrs, this.location, this.name);
            if (this.attrs.hasOwnProperty('href'))
                loadExternFile(this, parser, this.attrs.href, true);
            this.outputType = '.js';
        };

        Script.prototype.printBody = function (buffers, side) {
            if (this.attrs.hasOwnProperty('href'))
                buffers.merge(side, this.preparedBuffers, this.location.line);
else {
                var data = this.text;

                var newLocation = {
                    line: this.location.line,
                    col: this.location.col,
                    file: pr.resolveCheck(this.location.file, options.includes)
                };
                buffers.write(side, this.outputType, data, newLocation, true);
            }
        };
        return Script;
    })(Element);

    var Stylesheet = (function (_super) {
        __extends(Stylesheet, _super);
        function Stylesheet(parser, name, attrs, filename) {
            _super.call(this, parser, name, attrs, filename);
            this.elementRules = {};
            this.elementAttrs = ['system', 'href'];
            this.name = 'stylesheet';
            this.outputType = '.css';
            if (this.attrs.hasOwnProperty('system') && styleSheetEngine.hasOwnProperty(this.attrs.system))
                this.outputType = '.' + this.attrs.system;
            this.preparedBuffers = new BufferManager();
        }
        Stylesheet.prototype.prepare = function (parser) {
            this.checkAttrs(this.attrs, this.location, this.name);
            if (this.attrs.hasOwnProperty('href'))
                loadExternFile(this, parser, this.attrs.href, true);
        };

        Stylesheet.prototype.printBody = function (buffers, side) {
            if (this.attrs.hasOwnProperty('href'))
                buffers.merge(side, this.preparedBuffers, this.location.line);
else {
                var data = '';

                data += this.text;

                buffers.write(side, this.outputType, data, null, false);
            }
        };
        return Stylesheet;
    })(Element);

    var Template = (function (_super) {
        __extends(Template, _super);
        function Template(parser, name, attrs, filename) {
            _super.call(this, parser, name, attrs, filename);
            this.elementRules = {};
            this.elementAttrs = ['system', 'id', 'href'];
            this.name = 'template';
            this.templateName = 'square';
            if (this.attrs.hasOwnProperty('system') && templateEngine.hasOwnProperty(this.attrs.system))
                this.templateName = this.attrs.system;
        }
        Template.prototype.prepare = function (parser) {
            this.checkAttrs(this.attrs, this.location, this.name);
            if (this.attrs.hasOwnProperty('href'))
                this.templateContent = loadExternFile(this, parser, this.attrs.href, false);
            this.outputType = '.js';
        };

        Template.prototype.printHeader = function (buffers, side) {
            if (this.attrs.hasOwnProperty('id')) {
                if (Handler.prototype.isPrototypeOf(this.parent))
                    throw new Error('Embedded templates have no id!');
                var data = '';

                data += 'application.addTemplate(\"';
                data += this.attrs.id;
                data += '\", Object.create(Template.prototype, {\n';

                buffers.write(side, this.outputType, data, null, false);
            } else {
                if (!Handler.prototype.isPrototypeOf(this.parent))
                    throw new Error('Stand-alone templates must have an id!');
            }
        };

        Template.prototype.printBody = function (buffers, side) {
            var data = '';

            data += 'on_render';
            data += ': { value:\n';

            var cleaned;

            if (this.attrs.hasOwnProperty('href'))
                cleaned = this.templateContent.replace(/\s+/g, ' ');
else
                cleaned = this.text.replace(/\s+/g, ' ');
            cleaned = cleaned.replace(/\"/g, '\\\"');

            var bufferString = new Buffer(cleaned);
            var streamBuff = new sbuff.WritableStreamBuffer();

            var templateCompiler = new templateEngine[this.templateName].parse(bufferString);
            templateCompiler.print(streamBuff, '');

            data += streamBuff.getContentsAsString("utf8");
            data += '},\n';

            buffers.write(side, this.outputType, data, null, false);
        };

        Template.prototype.printFooter = function (buffers, side) {
            var data = '';
            if (this.attrs.hasOwnProperty('id')) {
                data += '\n}));\n\n';

                buffers.write(side, this.outputType, data, null, false);
            }
        };
        return Template;
    })(Element);

    var Client = (function (_super) {
        __extends(Client, _super);
        function Client(parser, name, attrs, filename) {
            _super.call(this, parser, name, attrs, filename);
            this.elementRules = {
                handler: Handler,
                include: Include,
                on: On,
                property: Property,
                script: Script,
                stylesheet: Stylesheet,
                template: Template
            };
            this.elementAttrs = [];
            this.name = 'client';
        }
        Client.prototype.print = function (buffers, side) {
            if (options.client || (!options.client && !options.server))
                Element.prototype.print.call(this, buffers, SideType.CLIENT);
        };
        return Client;
    })(Element);

    var Handler = (function (_super) {
        __extends(Handler, _super);
        function Handler(parser, name, attrs, filename) {
            _super.call(this, parser, name, attrs, filename);
            this.elementRules = {
                on: On,
                bind: Bind,
                template: Template
            };
            this.elementAttrs = ['url', 'type'];
            this.name = 'handler';
        }
        Handler.prototype.printHeader = function (buffers, side) {
            var data = '';

            data += 'application.addHandler(\"';
            data += this.attrs.url;
            data += '\", Object.create(Handler.prototype, {\n';
            data += 'url : { value: \"';
            data += this.attrs.url;
            data += '\"},\n';

            if (this.attrs.type) {
                data += 'contentType : { value: \"';
                data += this.attrs.type;
                data += '\"},\n';
            }

            buffers.write(side, this.outputType, data, null, false);
        };

        Handler.prototype.printFooter = function (buffers, side) {
            var data = '';

            data += '\n}));\n\n';

            buffers.write(side, this.outputType, data, null, false);
        };
        return Handler;
    })(Element);

    var Bind = (function (_super) {
        __extends(Bind, _super);
        function Bind(parser, name, attrs, filename) {
            _super.call(this, parser, name, attrs, filename);
            this.elementRules = {};
            this.elementAttrs = ['data', 'with'];
            this.name = 'bind';
        }
        Bind.prototype.printBody = function (buffers, side) {
            var data = '';

            data += 'application.addObserver(' + this.attrs.data + ', ' + this.attrs.with + ');\n';

            buffers.write(side, this.outputType, data, null, false);
        };
        return Bind;
    })(Element);

    var Server = (function (_super) {
        __extends(Server, _super);
        function Server(parser, name, attrs, filename) {
            _super.call(this, parser, name, attrs, filename);
            this.elementRules = {
                handler: Handler,
                include: Include,
                on: On,
                property: Property,
                script: Script,
                stylesheet: Stylesheet,
                template: Template
            };
            this.elementAttrs = [];
            this.name = 'server';
        }
        Server.prototype.print = function (buffers, side) {
            if (options.server || (!options.client && !options.server))
                Element.prototype.print.call(this, buffers, SideType.SERVER);
        };
        return Server;
    })(Element);

    var Application = (function (_super) {
        __extends(Application, _super);
        function Application(parser, name, attrs, filename) {
            _super.call(this, parser, name, attrs, filename);
            this.elementRules = {
                client: Client,
                handler: Handler,
                include: Include,
                property: Property,
                server: Server,
                script: Script,
                stylesheet: Stylesheet,
                template: Template
            };
            this.elementAttrs = ['xmlns'];
            this.name = 'application';
        }
        return Application;
    })(Element);

    var Roots = (function (_super) {
        __extends(Roots, _super);
        function Roots(parser, name, attrs, filename) {
            _super.call(this, parser, name, attrs, filename);
            this.elementRules = {
                application: Application
            };
            this.elementAttrs = [];
            this.name = 'roots';
        }
        return Roots;
    })(Element);

    /*
    ** Parse Arguments
    */
    function doParseArguments(options) {
        var argv = require('optimist').alias('c', 'client').alias('s', 'server').alias('v', 'version').boolean(['server', 'client', 'version']).string('o', 'i', 'hint').describe('c', 'compile for client').describe('s', 'compile for server').describe('i', 'include directory').describe('v', 'print the current version').describe('o', 'output basename').describe('hint', 'hint configuration').usage('$0' + ' version ' + version).demand('_').argv;

        options.server = argv.server;
        options.client = argv.client;

        if (argv.i) {
            if (argv.i instanceof Array)
                argv.i.forEach(function (elm) {
                    options.includes.push(elm);
                });
else
                options.includes.push(argv.i);
        }
        if (argv.hint) {
            if (argv.hint instanceof Array)
                options.jshint = loadJsHintFile(argv.hint[0]);
else
                options.jshint = loadJsHintFile(argv.hint);
        } else
            options.jshint = loadJsHintFile(null);
        if (argv.v) {
            console.log('version: ' + version);
        }
        if (argv.o)
            options.output = (argv.o instanceof Array) ? (argv.o.splice(-1)) : (argv.o);

        argv._.forEach(function (elm) {
            options.inputs.push(elm);
        });
    }

    /*
    ** parsing entry point and utils
    */
    function loadJsHintFile(file) {
        var data = '';
        try  {
            if (file == null) {
                throw Error('default file');
            }
            data = fs.readFileSync(file, 'utf-8');
        } catch (err) {
            console.log('using default jshint config file');
            try  {
                data = fs.readFileSync(__dirname + '/../sources/templates/jshint.json', 'utf-8');
            } catch (e) {
                data = '';
            }
        }
        return (JSON.parse(data));
    }

    function hint(chunk, sourceMap, output) {
        if (jshint(chunk, options.jshint) == false) {
            console.log();
            printHintErrors(jshint.data().errors, sourceMap, output);
            console.log();
            return (false);
        }
        return (true);
    }

    function doNextDocument() {
        if (options.inputs.length) {
            doParseDocument(options.inputs.shift(), doNextDocument);
        }
    }

    function doParseDocument(filename, callback) {
        var parser = new expat.Parser('UTF-8');
        parser.currentElement = null;
        parser.currentText = '';
        filename = pr.resolveCheck(filename, options.includes);

        addFileInSourceMapFolder(filename, options.output);
        parser.roots = new Roots(parser, 'roots', null, filename);

        parser.filename = filename;
        parser.elements = [parser];
        parser.wait = function (element) {
            this.elements.push(element);
        };
        parser.dequeue = function (element) {
            var index = this.elements.indexOf(element);
            if (index < 0)
                console.log('>>>> DEQUEUE UNKNOWN ELEMENT');
            this.elements.splice(index, 1);
            if (this.elements.length == 0) {
                var buffers = new BufferManager();
                this.currentElement.print(buffers, SideType.BOTH);

                if (callback)
                    callback(buffers);
            }
        };
        parser.error = function (e) {
            console.log(parser.filename + ':' + parser.getCurrentLineNumber() + ': error:' + e);
        };
        parser.addListener('error', function (e) {
            console.log(parser.filename + ':' + parser.getCurrentLineNumber() + ': error:' + e);
        });
        parser.addListener('startElement', function (name, attrs) {
            this.currentElement.processElement(parser, name, attrs, filename);
        });
        parser.addListener('endElement', function (name) {
            this.currentElement.stop(parser, name);
        });
        parser.addListener('text', function (s) {
            this.currentText += s;
        });
        parser.addListener('end', function () {
            try  {
                this.currentElement.prepare(parser);
                parser.dequeue(parser);
            } catch (err) {
                console.log(err);
            }
        });

        console.log('# parsing ' + parser.filename);
        parser.input = fs.createReadStream(parser.filename);
        parser.input.pipe(parser);
    }

    function checkWebKoolWkFileExistence(filename) {
        try  {
            var path = fs.realpathSync(filename);
        } catch (e) {
            var data = fs.readFileSync(__dirname + '/../sources/templates/webkool.wk');
            fs.writeFileSync(filename, data);
        }
    }

    function getDataFromSourceMap(sourceMap, side, type) {
        if (typeof sourceMap[type] === 'undefined' || typeof sourceMap[type][side] === 'undefined')
            return ('');
        return (JSON.stringify(sourceMap[type][side].toStringWithSourceMap({ file: ['webkool.wk'] }).map));
    }

    function getOutputName(side) {
        var filename = pathm.resolve(options.output);

        if (options.output[options.output.length - 1] == '/')
            filename += '/';

        if (side == SideType.CLIENT) {
            var client = filename + ((filename[filename.length - 1] == '/') ? ('client') : (''));
            return ([client, null]);
        }
        if (side == SideType.SERVER) {
            var server = filename + ((filename[filename.length - 1] == '/') ? ('server') : (''));
            return ([null, server]);
        }
        if (side == SideType.BOTH) {
            var client = filename + ((filename[filename.length - 1] == '/') ? ('') : ('.')) + 'client';
            var server = filename + ((filename[filename.length - 1] == '/') ? ('') : ('.')) + 'server';
            return ([client, server]);
        } else {
            return (null);
        }
    }

    function createFilesForSide(side, buffers, filename, smfilename) {
        if (side == SideType.BOTH) {
            var rs = createFilesForSide(SideType.SERVER, buffers, filename[1], smfilename[1]);
            var rc = createFilesForSide(SideType.CLIENT, buffers, filename[0], smfilename[0]);
            if (rc && rs) {
                return ([rs[0].concat(rc[0]), rs[1].concat(rc[1])]);
            }
            return (null);
        } else {
            if (Array.isArray(filename))
                filename = (side == SideType.CLIENT) ? (filename[0]) : (filename[1]);
            if (Array.isArray(smfilename))
                smfilename = (side == SideType.CLIENT) ? (smfilename[0]) : (smfilename[1]);
            var errorInFile = false;
            var tmpFiles = [];
            var tmpFilesSourceMap = [];
            var buff = buffers.getBuffers();
            for (var i = 0; i < buff.length; i++) {
                if (buff[i].side == side && (buff[i].name == '.js' || buff[i].name == '.css')) {
                    var txt = buffers.toString(side, buff[i].name);

                    var ext = buff[i].name + '.tmp';
                    var extsm = buff[i].name + '.map.tmp';

                    var relSource = pr.getRelative(pr.getSourceMap(), pr.getRoot()) + '/' + filename.substr(filename.lastIndexOf('/') + 1) + ext;
                    var relPath = pr.getRelative(pr.getRoot(), pr.getSourceMap()) + '/' + filename.substr(filename.lastIndexOf('/') + 1) + extsm;

                    var sourceMap = buffers.toSourceMap(side, buff[i].name, relSource);
                    var sourceMapGenerated = sourceMap.toString();

                    var outputPath = filename + ext;
                    var outputSourceMapPath = smfilename + extsm;

                    txt += '//# sourceMappingURL=' + relPath;
                    fs.writeFile(outputSourceMapPath, sourceMapGenerated);
                    fs.writeFile(outputPath, txt);

                    console.log('# saving in file ' + outputPath.substr(0, outputPath.length - '.tmp'.length));
                    console.log('# saving in file ' + outputSourceMapPath.substr(0, outputSourceMapPath.length - '.tmp'.length));

                    if (buff[i].name == '.js') {
                        if (hint(txt, JSON.parse(sourceMapGenerated), filename))
                            tmpFiles.push(outputPath);
else
                            errorInFile = true;
                    } else
                        tmpFiles.push(outputPath);
                    tmpFilesSourceMap.push(outputSourceMapPath);
                }
            }
            if (errorInFile)
                return (null);
            return ([tmpFiles, tmpFilesSourceMap]);
        }
    }

    function joinBuffers(side, buffers) {
        if (side == SideType.BOTH) {
            joinBuffers(SideType.SERVER, buffers);
            joinBuffers(SideType.CLIENT, buffers);
        } else {
            for (var eng in styleSheetEngine) {
                if (eng != 'css') {
                    var streamBuff = new sbuff.WritableStreamBuffer();
                    var inp = buffers.toString(side, '.' + eng);
                    if (inp != '') {
                        styleSheetEngine[eng].compile(inp, streamBuff);
                        var line = buffers.get(side, '.css', true).data.length;
                        var data = streamBuff.getContentsAsString("utf8");
                        buffers.write(side, '.css', data, null, false);
                    }
                }
            }

            if (side == SideType.SERVER) {
                var line = buffers.get(SideType.SERVER, '.js', true).data.length;
                buffers.write(SideType.SERVER, '.js', '\napplication.start();\n', null, false);
            }
        }
    }

    function generateSourceMapFolder(where) {
        var folder = pr.getSourceMap();
        try  {
            fs.mkdirSync(folder);
        } catch (ignore) {
        }
    }

    function addFileInSourceMapFolder(file, where) {
        try  {
            var name = file.substr(file.lastIndexOf('/') + 1);

            var sm = pr.getSourceMap() + name;
            var fin = fs.createReadStream(file);
            var fout = fs.createWriteStream(sm);

            fin.pipe(fout);
        } catch (e) {
            console.log('error: file not found <' + file + '>');
        }
    }

    function moveTmp(tmpFiles) {
        tmpFiles.forEach(function (itm) {
            var filename = itm.substr(0, itm.length - '.tmp'.length);

            var fin = fs.createReadStream(itm);
            var fout = fs.createWriteStream(filename);
            fin.pipe(fout);
            fin.on('end', function () {
                fs.unlinkSync(itm);
            });
        });
    }

    function replaceTmpInFile(tmpFiles, tmpFilesSourceMap) {
        tmpFiles.forEach(function (itm) {
            var filename = itm.substr(0, itm.length - '.tmp'.length);

            async.waterfall([
                function (callback) {
                    var data = fs.readFileSync(filename);
                    callback(null, data);
                },
                function (data, callback) {
                    var res = data.toString().replace(/(\/\/# sourceMappingURL=.+)\.tmp$/, '$1');
                    callback(null, res);
                },
                function (res, callback) {
                    fs.writeFileSync(filename, res);
                    callback(null);
                }
            ]);
        });
        tmpFilesSourceMap.forEach(function (itm) {
            var filename = itm.substr(0, itm.length - '.tmp'.length);

            async.waterfall([
                function (callback) {
                    var data = fs.readFileSync(filename);
                    callback(null, data);
                },
                function (data, callback) {
                    var res = JSON.parse(data.toString());
                    res.file = res.file.substr(0, res.file.length - '.tmp'.length);
                    for (var i = 0; i < res.sources.length; i++)
                        res.sources[i] = res.sources[i].substr(res.sources[i].lastIndexOf('/') + 1);
                    callback(null, res);
                },
                function (res, callback) {
                    fs.writeFileSync(filename, JSON.stringify(res));
                    callback(null);
                }
            ]);
        });
    }

    function unitPath() {
        var paths = [
            '/plop/lal/toto',
            '/plop/lal/',
            'toto',
            './',
            '',
            '../plop/',
            '../plop',
            'plop/lal/toto',
            'plop/lal/toto/'
        ];

        paths.forEach(function (itm) {
            console.log('---------------------------');
            console.log('output: <' + itm + '>');
            var p = new PathRes(itm);

            console.log('root: <' + p.getRoot() + '>');
            console.log('file: <' + p.getFile() + '>');
            console.log('out: <SERVER><' + p.getOutputName(SideType.SERVER)[1] + '>');
            console.log('out: <CLIENT><' + p.getOutputName(SideType.CLIENT)[0] + '>');
            console.log('out: <BOTH><' + p.getOutputName(SideType.BOTH) + '>');
            console.log('sourcemap: <' + p.getSourceMap() + '>');
            console.log('resolve: <plop.js><' + p.resolve(p.getRoot(), 'plop.js') + '>');
            console.log('resolve: <../plop.js><' + p.resolve(p.getRoot(), '../plop.js') + '>');
            console.log('resolve: <plop/plop.js><' + p.resolve(p.getRoot(), 'plop/plop.js') + '>');
            console.log('resolve: <../plop/plop.js>' + p.resolve(p.getRoot(), '../plop/plop.js') + '>');
            console.log('resolve: <><' + p.resolve(p.getRoot(), '') + '>');
            console.log('resolve: <plap/><' + p.resolve(p.getRoot(), 'plap/') + '>');
        });
    }

    function run() {
        doParseArguments(options);

        pr = new PathRes(options.output);
        options.includes.push(pr.getRoot());
        var entryFile = pr.resolveCheck(options.inputs.shift(), options.includes);
        var webkoolFile = pr.resolve(pr.getCurrentFolder(), 'webkool.wk');

        checkWebKoolWkFileExistence(webkoolFile);
        generateSourceMapFolder(options.output);

        //begin the parsing of webkool.wk
        doParseDocument(webkoolFile, function (initialBuffers) {
            var _buffers = initialBuffers;

            //parse the entry point (index.wk for example)
            doParseDocument(entryFile, function (buffers) {
                _buffers.merge(SideType.BOTH, buffers, 0);

                //process some operation over buffer
                joinBuffers(SideType.BOTH, _buffers);

                //write in file
                async.waterfall([
                    function (callback) {
                        var side = pr.getSide(options.client, options.server);
                        var tmpFiles = createFilesForSide(side, _buffers, pr.getOutputName(side), pr.getSourceMapName(side));
                        callback(null, tmpFiles);
                    },
                    function (tmpFiles, callback) {
                        if (tmpFiles != null)
                            moveTmp(tmpFiles[0].concat(tmpFiles[1]));
                        callback(null, tmpFiles);
                    },
                    function (tmpFiles, callback) {
                        if (tmpFiles != null)
                            replaceTmpInFile(tmpFiles[0], tmpFiles[1]);
                        callback(null, tmpFiles);
                    }
                ]);
            });
        });
    }
    Webkool.run = run;
})(Webkool || (Webkool = {}));

Webkool.run();
